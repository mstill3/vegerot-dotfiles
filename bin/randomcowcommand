#!/usr/bin/env bash

set -e
set -o pipefail

find_random_manpage() {
	OLDIFS=$IFS
	IFS=:
 	for dir in $(manpath -q); do
 		[[ -n $dir ]] && printf "%s\n" $dir/man1/* | grep -i perl
 	done | shuf -n 1
	IFS=$OLDIFS
}
manpagefile=$(find_random_manpage)
get_description_of_manpage() {
  if ! type lexgrog > /dev/null 2>&1; then
	  #local manPageText="$(man -P cat $1)"
	  ## HACK(max): If you give `man` the path to the file, it won't correctly
	  # import `.so`s (because it `cd`s to the wrong directory for the relative
	  # imports to work).
	  # Workaround: do what `man FILEPATH` does, but in the right directory.
	  cd $(dirname $1)/..
	  local manPageText=$(/usr/bin/zcat -f "$1" | /usr/bin/mandoc)
	  local formatted=$(echo "$manPageText" | col -bpx | grep NAME -A1 | tail -1)
	  if [[ -z "$formatted" ]]; then
		  echo "randomcowcommand: We messed up with $1" 1>&2
	  fi
	  echo $formatted
  else
    lexgrog -w $1 | shuf -n 1 | sed -E 's/^.*: "(.*)"$/\1/'
  fi
}
commanddescription=$(get_description_of_manpage $manpagefile)
if [[ -z "$commanddescription" ]]; then
	# we'll never get two duds in a row, right?
	manpagefile=$(find_random_manpage)
	commanddescription=$(get_description_of_manpage $manpagefile)
fi
cow=$(echo "$commanddescription" | cowsay -f $( cowsay -l| tail -n+2|tr " " "\n"|sort -R|head -1))
if type rainbow 2>&1 1> /dev/null; then
	echo "$cow" | rainbow
else
	echo "$cow"
fi



# fun benchmark:
#
# ```sh
# hyperfine -w 2 \
# 	'find $(manpath -q | tr ":" " ") -type f -name "*.1" | shuf -n 1' \
# 	'gfind $(manpath -q | tr ":" " ") -type f -name "*.1" | shuf -n 1' \
# 	'fd \.1 $(manpath -q | tr ":" " ") --type=file | shuf -n 1' \
# 	'OLDIFS=$IFS
# 	IFS=:
# 	for dir in $(manpath -q); do
# 		[[ -n $dir ]] && printf "%s\n" $dir/man1/* | grep -i perl
# 	done | shuf -n 1
# 	IFS=$OLDIFS'
# 	'
# 	OLDIFS=$IFS
# 	IFS=:
# 	for dir in $(manpath -q); do
# 		[[ -n $dir ]] && fd --exact-depth=2 . $dir/ | grep -i perl
# 	done | shuf -n 1
# 	IFS=$OLDIFS
# 	'
#```

